{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/lib/moongoose.js"],"sourcesContent":["import mongoose from \"mongoose\";\n\n// Don't check MONGODB_URI at module level - check it when connecting\n// This prevents build-time errors since env vars may not be available during build\nfunction getMongoDBUri() {\n  const uri =\n    process.env.MONGODB_URI ||\n    \"mongodb+srv://sourabhmalame:sourabh1234@pgadmin.evcqvgp.mongodb.net/?appName=pgadmin\";\n  if (!uri) {\n    throw new Error(\n      \"❌ MONGODB_URI is missing. Please set it in your environment variables (Vercel: Settings > Environment Variables)\"\n    );\n  }\n  return uri;\n}\n\nlet cached = global._mongoose;\nif (!cached) cached = global._mongoose = { conn: null, promise: null };\n\n// Check if mongoose is already connected\nfunction isConnected() {\n  return mongoose.connection.readyState === 1;\n}\n\n/**\n * Connect to MongoDB database\n * Uses connection pooling and caching to reuse connections\n * Only connects once, subsequent calls reuse the existing connection\n * This should be called at login to establish the connection\n */\nexport async function connectDB() {\n  // If mongoose is already connected, return immediately (no need to check cache)\n  if (isConnected()) {\n    return mongoose.connection;\n  }\n\n  // If connection exists in cache and is still valid, return it\n  if (cached.conn && isConnected()) {\n    return cached.conn;\n  }\n\n  // If connection is in progress, wait for it\n  if (cached.promise) {\n    try {\n      cached.conn = await cached.promise;\n      return cached.conn;\n    } catch (error) {\n      cached.promise = null;\n      throw error;\n    }\n  }\n\n  // Get MongoDB URI (will throw error if not set)\n  const mongoUri = getMongoDBUri();\n\n  // Create new connection promise\n  cached.promise = mongoose.connect(mongoUri, {\n    bufferCommands: false, // Fail fast if not connected\n    serverSelectionTimeoutMS: 10000, // Increased timeout\n    socketTimeoutMS: 45000, // Socket timeout\n    connectTimeoutMS: 10000, // Connection timeout\n    retryWrites: true,\n    w: \"majority\",\n  });\n\n  try {\n    cached.conn = await cached.promise;\n    console.log(\"✅ Mongoose connected to MongoDB\");\n\n    // Handle connection events\n    mongoose.connection.on(\"error\", (err) => {\n      console.error(\"MongoDB connection error:\", err);\n      cached.conn = null;\n      cached.promise = null;\n    });\n\n    mongoose.connection.on(\"disconnected\", () => {\n      console.warn(\"MongoDB disconnected\");\n      cached.conn = null;\n      cached.promise = null;\n    });\n\n    return cached.conn;\n  } catch (error) {\n    cached.promise = null;\n    cached.conn = null;\n    console.error(\"Failed to connect to MongoDB:\", error);\n\n    // Provide more helpful error messages\n    if (error.code === \"ECONNREFUSED\") {\n      console.error(\n        \"❌ MongoDB connection refused. Please check:\\n\" +\n          \"1. Your MongoDB Atlas cluster is running\\n\" +\n          \"2. Your IP address is whitelisted in MongoDB Atlas\\n\" +\n          \"3. Your connection string is correct\\n\" +\n          \"4. Your network connection is working\"\n      );\n    } else if (error.name === \"MongoServerError\") {\n      console.error(\"❌ MongoDB server error:\", error.message);\n    } else if (error.name === \"MongoNetworkError\") {\n      console.error(\"❌ MongoDB network error:\", error.message);\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Ensure database is connected (for routes that assume connection exists)\n * If not connected, will connect (fallback for routes called before login)\n */\nexport async function ensureConnected() {\n  if (isConnected()) {\n    return mongoose.connection;\n  }\n  // Fallback: connect if not already connected\n  return await connectDB();\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,qEAAqE;AACrE,mFAAmF;AACnF,SAAS;IACP,MAAM,MACJ,QAAQ,GAAG,CAAC,WAAW,IACvB;IACF;;IAKA,OAAO;AACT;AAEA,IAAI,SAAS,yDAAO,SAAS;AAC7B,IAAI,CAAC,QAAQ,SAAS,yDAAO,SAAS,GAAG;IAAE,MAAM;IAAM,SAAS;AAAK;AAErE,yCAAyC;AACzC,SAAS;IACP,OAAO,oHAAQ,CAAC,UAAU,CAAC,UAAU,KAAK;AAC5C;AAQO,eAAe;IACpB,gFAAgF;IAChF,IAAI,eAAe;QACjB,OAAO,oHAAQ,CAAC,UAAU;IAC5B;IAEA,8DAA8D;IAC9D,IAAI,OAAO,IAAI,IAAI,eAAe;QAChC,OAAO,OAAO,IAAI;IACpB;IAEA,4CAA4C;IAC5C,IAAI,OAAO,OAAO,EAAE;QAClB,IAAI;YACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;YAClC,OAAO,OAAO,IAAI;QACpB,EAAE,OAAO,OAAO;YACd,OAAO,OAAO,GAAG;YACjB,MAAM;QACR;IACF;IAEA,gDAAgD;IAChD,MAAM,WAAW;IAEjB,gCAAgC;IAChC,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,UAAU;QAC1C,gBAAgB;QAChB,0BAA0B;QAC1B,iBAAiB;QACjB,kBAAkB;QAClB,aAAa;QACb,GAAG;IACL;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;QAClC,QAAQ,GAAG,CAAC;QAEZ,2BAA2B;QAC3B,oHAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,CAAC;YAC/B,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO,IAAI,GAAG;YACd,OAAO,OAAO,GAAG;QACnB;QAEA,oHAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,gBAAgB;YACrC,QAAQ,IAAI,CAAC;YACb,OAAO,IAAI,GAAG;YACd,OAAO,OAAO,GAAG;QACnB;QAEA,OAAO,OAAO,IAAI;IACpB,EAAE,OAAO,OAAO;QACd,OAAO,OAAO,GAAG;QACjB,OAAO,IAAI,GAAG;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAE/C,sCAAsC;QACtC,IAAI,MAAM,IAAI,KAAK,gBAAgB;YACjC,QAAQ,KAAK,CACX,kDACE,+CACA,yDACA,2CACA;QAEN,OAAO,IAAI,MAAM,IAAI,KAAK,oBAAoB;YAC5C,QAAQ,KAAK,CAAC,2BAA2B,MAAM,OAAO;QACxD,OAAO,IAAI,MAAM,IAAI,KAAK,qBAAqB;YAC7C,QAAQ,KAAK,CAAC,4BAA4B,MAAM,OAAO;QACzD;QAEA,MAAM;IACR;AACF;AAMO,eAAe;IACpB,IAAI,eAAe;QACjB,OAAO,oHAAQ,CAAC,UAAU;IAC5B;IACA,6CAA6C;IAC7C,OAAO,MAAM;AACf"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/models/Post.js"],"sourcesContent":["import mongoose from \"mongoose\";\n\nconst PostSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true },\n    slug: { type: String, required: true, unique: true },\n    excerpt: { type: String },\n    content: { type: String, required: true, default: \"\" },\n    contentBlocks: { type: Array, default: [] },\n    category: { type: String, required: true },\n    featuredImage: { type: String },\n    status: {\n      type: String,\n      enum: [\"draft\", \"pending\", \"published\"],\n      default: \"draft\",\n    },\n    author: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: \"User\",\n      required: true,\n    },\n    autoShareEnabled: {\n      type: Boolean,\n      default: false,\n    },\n    publishedAt: { type: Date },\n    // SEO Fields\n    seo: {\n      metaTitle: { type: String },\n      metaDescription: { type: String },\n      metaKeywords: { type: String },\n      ogTitle: { type: String },\n      ogDescription: { type: String },\n      ogImage: { type: String },\n      twitterCard: { type: String, default: \"summary_large_image\" },\n    },\n  },\n  { timestamps: true }\n);\n\n// Generate slug from title before saving\nPostSchema.pre(\"save\", async function () {\n  try {\n    // Always generate slug if it doesn't exist or is empty\n    if (!this.slug || this.slug.trim() === \"\") {\n      if (this.title && this.title.trim() !== \"\") {\n        this.slug = this.title\n          .toLowerCase()\n          .replace(/[^a-z0-9]+/g, \"-\")\n          .replace(/(^-|-$)/g, \"\");\n      }\n    } else if (\n      this.isModified(\"title\") &&\n      this.title &&\n      this.title.trim() !== \"\"\n    ) {\n      // If title is modified, regenerate slug\n      this.slug = this.title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, \"-\")\n        .replace(/(^-|-$)/g, \"\");\n    }\n\n    // Ensure slug is not empty (fallback) - this is critical for required field\n    if (!this.slug || this.slug.trim() === \"\") {\n      const timestamp = Date.now();\n      const random = Math.random().toString(36).substring(2, 8);\n      this.slug = `post-${timestamp}-${random}`;\n    }\n\n    // Ensure slug doesn't start or end with dash\n    this.slug = this.slug.replace(/(^-|-$)/g, \"\");\n\n    if (this.status === \"published\" && !this.publishedAt) {\n      this.publishedAt = new Date();\n    }\n  } catch (error) {\n    console.error(\"Error in pre-save hook:\", error);\n    // If slug generation fails, use timestamp-based fallback\n    if (!this.slug || this.slug.trim() === \"\") {\n      const timestamp = Date.now();\n      const random = Math.random().toString(36).substring(2, 8);\n      this.slug = `post-${timestamp}-${random}`;\n    }\n  }\n});\n\nexport default mongoose.models.Post || mongoose.model(\"Post\", PostSchema);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/models/User.js"],"sourcesContent":["import mongoose from \"mongoose\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nconst UserSchema = new mongoose.Schema(\r\n  {\r\n    name: { type: String, required: true },\r\n    email: { type: String, required: true, unique: true },\r\n    password: { type: String, required: true },\r\n    role: { \r\n      type: String, \r\n      enum: ['NORMAL_USER', 'ADMIN'], \r\n      default: 'NORMAL_USER' \r\n    },\r\n    accountType: {\r\n      type: String,\r\n      enum: ['individual', 'organization'],\r\n      default: 'individual'\r\n    },\r\n    organizationName: {\r\n      type: String,\r\n      default: null\r\n    },\r\n    organizationWebsite: {\r\n      type: String,\r\n      default: null\r\n    },\r\n    organizationDescription: {\r\n      type: String,\r\n      default: null\r\n    },\r\n    autoShareEnabled: { \r\n      type: Boolean, \r\n      default: false \r\n    },\r\n    socialMediaSettings: {\r\n      facebook: { type: Boolean, default: false },\r\n      twitter: { type: Boolean, default: false },\r\n      instagram: { type: Boolean, default: false },\r\n      linkedin: { type: Boolean, default: false },\r\n      youtube: { type: Boolean, default: false },\r\n    },\r\n  },\r\n  { timestamps: true }\r\n);\r\n\r\n// Pre-save hook to hash password\r\nUserSchema.pre(\"save\", async function () {\r\n  if (!this.isModified(\"password\")) return;\r\n  this.password = await bcrypt.hash(this.password, 10);\r\n});\r\n\r\n// Pre-save hook to ensure role is always set to NORMAL_USER for new users\r\n// (unless explicitly set to ADMIN by authorized routes)\r\nUserSchema.pre(\"save\", async function () {\r\n  // Only set default role if this is a new document and role is not already set\r\n  if (this.isNew && !this.role) {\r\n    this.role = \"NORMAL_USER\";\r\n  }\r\n  // Ensure role is valid enum value\r\n  if (this.role && ![\"NORMAL_USER\", \"ADMIN\"].includes(this.role)) {\r\n    this.role = \"NORMAL_USER\";\r\n  }\r\n});\r\n\r\nexport default mongoose.models.User || mongoose.model(\"User\", UserSchema);\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CACpC;IACE,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;QAAM,QAAQ;IAAK;IACpD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,MAAM;QACJ,MAAM;QACN,MAAM;YAAC;YAAe;SAAQ;QAC9B,SAAS;IACX;IACA,aAAa;QACX,MAAM;QACN,MAAM;YAAC;YAAc;SAAe;QACpC,SAAS;IACX;IACA,kBAAkB;QAChB,MAAM;QACN,SAAS;IACX;IACA,qBAAqB;QACnB,MAAM;QACN,SAAS;IACX;IACA,yBAAyB;QACvB,MAAM;QACN,SAAS;IACX;IACA,kBAAkB;QAChB,MAAM;QACN,SAAS;IACX;IACA,qBAAqB;QACnB,UAAU;YAAE,MAAM;YAAS,SAAS;QAAM;QAC1C,SAAS;YAAE,MAAM;YAAS,SAAS;QAAM;QACzC,WAAW;YAAE,MAAM;YAAS,SAAS;QAAM;QAC3C,UAAU;YAAE,MAAM;YAAS,SAAS;QAAM;QAC1C,SAAS;YAAE,MAAM;YAAS,SAAS;QAAM;IAC3C;AACF,GACA;IAAE,YAAY;AAAK;AAGrB,iCAAiC;AACjC,WAAW,GAAG,CAAC,QAAQ;IACrB,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa;IAClC,IAAI,CAAC,QAAQ,GAAG,MAAM,8IAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;AACnD;AAEA,0EAA0E;AAC1E,wDAAwD;AACxD,WAAW,GAAG,CAAC,QAAQ;IACrB,8EAA8E;IAC9E,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;QAC5B,IAAI,CAAC,IAAI,GAAG;IACd;IACA,kCAAkC;IAClC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;QAAC;QAAe;KAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG;QAC9D,IAAI,CAAC,IAAI,GAAG;IACd;AACF;uCAEe,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAC,QAAQ"}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/app/api/posts/route.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { ensureConnected } from \"@/lib/moongoose\";\nimport Post from \"@/models/Post\";\nimport User from \"@/models/User\";\nimport jwt from \"jsonwebtoken\";\n\n// Next.js: Get env vars at runtime\nfunction getJWTSecret() {\n  return process.env.JWT_SECRET || \"your-secret-key-change-in-production\";\n}\n\n// Middleware to check if user is authenticated (both NORMAL_USER and ADMIN can create posts)\nasync function checkAuth(request) {\n  const token = request.cookies.get(\"token\")?.value;\n  if (!token) {\n    return { error: \"Not authenticated\", status: 401 };\n  }\n\n  try {\n    await ensureConnected();\n    const JWT_SECRET = getJWTSecret();\n    const decoded = jwt.verify(token, JWT_SECRET);\n    const user = await User.findById(decoded.userId).select(\"-password\");\n\n    if (!user) {\n      return {\n        error: \"User not found\",\n        status: 404,\n      };\n    }\n\n    // Allow both NORMAL_USER and ADMIN to create posts\n    if (user.role !== \"NORMAL_USER\" && user.role !== \"ADMIN\") {\n      return {\n        error: \"Unauthorized - Invalid user role\",\n        status: 403,\n      };\n    }\n\n    return { user };\n  } catch (error) {\n    return { error: \"Not authenticated\", status: 401 };\n  }\n}\n\n// Create a new post\nexport async function POST(request) {\n  const authCheck = await checkAuth(request);\n  if (authCheck.error) {\n    return NextResponse.json(\n      { error: authCheck.error },\n      { status: authCheck.status }\n    );\n  }\n\n  try {\n    const body = await request.json();\n    const { title, content, category, status, featuredImage, contentBlocks, excerpt, seo } = body;\n\n    // Validate required fields\n    if (!title || !category) {\n      return NextResponse.json(\n        { error: \"Title and category are required\" },\n        { status: 400 }\n      );\n    }\n\n    await ensureConnected();\n\n    // Generate slug from title\n    let slug = title\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, \"-\")\n      .replace(/(^-|-$)/g, \"\");\n\n    // Check if slug already exists and append a number if needed\n    let slugExists = true;\n    let slugCounter = 1;\n    let finalSlug = slug;\n    \n    while (slugExists) {\n      const existingPost = await Post.findOne({ slug: finalSlug });\n      if (!existingPost) {\n        slugExists = false;\n      } else {\n        finalSlug = `${slug}-${slugCounter}`;\n        slugCounter++;\n      }\n    }\n\n    // Ensure content is not empty (required field)\n    const postContent = content && content.trim() !== \"\" ? content : \"No content provided\";\n    \n    // Create the post with the authenticated user as author\n    const post = await Post.create({\n      title,\n      slug: finalSlug,\n      excerpt: excerpt || \"\",\n      content: postContent,\n      category,\n      status: status || \"draft\",\n      featuredImage: featuredImage || \"\",\n      contentBlocks: contentBlocks || [],\n      author: authCheck.user._id,\n      seo: seo || {},\n    });\n\n    // Populate author info for response\n    await post.populate(\"author\", \"name email\");\n\n    return NextResponse.json(\n      { post, message: \"Post created successfully\" },\n      { status: 201 }\n    );\n  } catch (error) {\n    console.error(\"Error creating post:\", error);\n    console.error(\"Error details:\", {\n      name: error.name,\n      message: error.message,\n      code: error.code,\n      errors: error.errors,\n      stack: error.stack\n    });\n    \n    // Handle duplicate slug error\n    if (error.code === 11000) {\n      return NextResponse.json(\n        { error: \"A post with this title already exists. Please try a different title.\" },\n        { status: 400 }\n      );\n    }\n\n    // Handle validation errors\n    if (error.name === \"ValidationError\") {\n      const validationErrors = Object.values(error.errors || {}).map(err => err.message).join(\", \");\n      return NextResponse.json(\n        { error: `Validation error: ${validationErrors || error.message}` },\n        { status: 400 }\n      );\n    }\n\n    // Return more detailed error message for debugging\n    return NextResponse.json(\n      { \n        error: error.message || \"Failed to create post\",\n        errorName: error.name,\n        details: process.env.NODE_ENV === \"development\" ? error.stack : undefined\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// Get posts (optional - for fetching user's own posts)\nexport async function GET(request) {\n  const authCheck = await checkAuth(request);\n  if (authCheck.error) {\n    return NextResponse.json(\n      { error: authCheck.error },\n      { status: authCheck.status }\n    );\n  }\n\n  try {\n    await ensureConnected();\n    \n    // Get posts created by the authenticated user\n    const posts = await Post.find({ author: authCheck.user._id })\n      .populate(\"author\", \"name email\")\n      .sort({ createdAt: -1 });\n\n    return NextResponse.json({ posts });\n  } catch (error) {\n    console.error(\"Error fetching posts:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch posts\" },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}