{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/lib/moongoose.js"],"sourcesContent":["import mongoose from \"mongoose\";\n\n// Don't check MONGODB_URI at module level - check it when connecting\n// This prevents build-time errors since env vars may not be available during build\nfunction getMongoDBUri() {\n  const uri =\n    process.env.MONGODB_URI ||\n    \"mongodb+srv://sourabhmalame:sourabh1234@pgadmin.evcqvgp.mongodb.net/?appName=pgadmin\";\n  if (!uri) {\n    throw new Error(\n      \"❌ MONGODB_URI is missing. Please set it in your environment variables (Vercel: Settings > Environment Variables)\"\n    );\n  }\n  return uri;\n}\n\nlet cached = global._mongoose;\nif (!cached) cached = global._mongoose = { conn: null, promise: null };\n\n// Check if mongoose is already connected\nfunction isConnected() {\n  return mongoose.connection.readyState === 1;\n}\n\n/**\n * Connect to MongoDB database\n * Uses connection pooling and caching to reuse connections\n * Only connects once, subsequent calls reuse the existing connection\n * This should be called at login to establish the connection\n */\nexport async function connectDB() {\n  // If mongoose is already connected, return immediately (no need to check cache)\n  if (isConnected()) {\n    return mongoose.connection;\n  }\n\n  // If connection exists in cache and is still valid, return it\n  if (cached.conn && isConnected()) {\n    return cached.conn;\n  }\n\n  // If connection is in progress, wait for it\n  if (cached.promise) {\n    try {\n      cached.conn = await cached.promise;\n      return cached.conn;\n    } catch (error) {\n      cached.promise = null;\n      throw error;\n    }\n  }\n\n  // Get MongoDB URI (will throw error if not set)\n  const mongoUri = getMongoDBUri();\n\n  // Create new connection promise with optimized settings for slow networks\n  cached.promise = mongoose.connect(mongoUri, {\n    bufferCommands: false, // Fail fast if not connected\n    serverSelectionTimeoutMS: 30000, // Increased to 30 seconds for slow networks\n    socketTimeoutMS: 60000, // Increased socket timeout to 60 seconds\n    connectTimeoutMS: 30000, // Increased connection timeout to 30 seconds\n    maxPoolSize: 10, // Connection pool size\n    minPoolSize: 1, // Minimum connections\n    maxIdleTimeMS: 30000, // Close connections after 30 seconds of inactivity\n    retryWrites: true,\n    retryReads: true, // Retry reads on network errors\n    w: \"majority\",\n    // Additional options for slow/unstable networks\n    heartbeatFrequencyMS: 10000, // Check connection health every 10 seconds\n    serverSelectionRetryDelayMS: 5000, // Wait 5 seconds between retry attempts\n  });\n\n  try {\n    cached.conn = await cached.promise;\n    console.log(\"✅ Mongoose connected to MongoDB\");\n\n    // Handle connection events\n    mongoose.connection.on(\"error\", (err) => {\n      console.error(\"MongoDB connection error:\", err);\n      cached.conn = null;\n      cached.promise = null;\n    });\n\n    mongoose.connection.on(\"disconnected\", () => {\n      console.warn(\"MongoDB disconnected\");\n      cached.conn = null;\n      cached.promise = null;\n    });\n\n    return cached.conn;\n  } catch (error) {\n    cached.promise = null;\n    cached.conn = null;\n    console.error(\"Failed to connect to MongoDB:\", error);\n\n    // Provide more helpful error messages\n    if (error.code === \"ECONNREFUSED\") {\n      console.error(\n        \"❌ MongoDB connection refused. Please check:\\n\" +\n          \"1. Your MongoDB Atlas cluster is running\\n\" +\n          \"2. Your IP address is whitelisted in MongoDB Atlas\\n\" +\n          \"3. Your connection string is correct\\n\" +\n          \"4. Your network connection is working\"\n      );\n    } else if (error.name === \"MongoServerError\") {\n      console.error(\"❌ MongoDB server error:\", error.message);\n    } else if (error.name === \"MongoNetworkError\") {\n      console.error(\"❌ MongoDB network error:\", error.message);\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Ensure database is connected (for routes that assume connection exists)\n * If not connected, will connect (fallback for routes called before login)\n */\nexport async function ensureConnected() {\n  if (isConnected()) {\n    return mongoose.connection;\n  }\n  // Fallback: connect if not already connected\n  return await connectDB();\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,qEAAqE;AACrE,mFAAmF;AACnF,SAAS;IACP,MAAM,MACJ,QAAQ,GAAG,CAAC,WAAW,IACvB;IACF;;IAKA,OAAO;AACT;AAEA,IAAI,SAAS,yDAAO,SAAS;AAC7B,IAAI,CAAC,QAAQ,SAAS,yDAAO,SAAS,GAAG;IAAE,MAAM;IAAM,SAAS;AAAK;AAErE,yCAAyC;AACzC,SAAS;IACP,OAAO,oHAAQ,CAAC,UAAU,CAAC,UAAU,KAAK;AAC5C;AAQO,eAAe;IACpB,gFAAgF;IAChF,IAAI,eAAe;QACjB,OAAO,oHAAQ,CAAC,UAAU;IAC5B;IAEA,8DAA8D;IAC9D,IAAI,OAAO,IAAI,IAAI,eAAe;QAChC,OAAO,OAAO,IAAI;IACpB;IAEA,4CAA4C;IAC5C,IAAI,OAAO,OAAO,EAAE;QAClB,IAAI;YACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;YAClC,OAAO,OAAO,IAAI;QACpB,EAAE,OAAO,OAAO;YACd,OAAO,OAAO,GAAG;YACjB,MAAM;QACR;IACF;IAEA,gDAAgD;IAChD,MAAM,WAAW;IAEjB,0EAA0E;IAC1E,OAAO,OAAO,GAAG,oHAAQ,CAAC,OAAO,CAAC,UAAU;QAC1C,gBAAgB;QAChB,0BAA0B;QAC1B,iBAAiB;QACjB,kBAAkB;QAClB,aAAa;QACb,aAAa;QACb,eAAe;QACf,aAAa;QACb,YAAY;QACZ,GAAG;QACH,gDAAgD;QAChD,sBAAsB;QACtB,6BAA6B;IAC/B;IAEA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;QAClC,QAAQ,GAAG,CAAC;QAEZ,2BAA2B;QAC3B,oHAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,CAAC;YAC/B,QAAQ,KAAK,CAAC,6BAA6B;YAC3C,OAAO,IAAI,GAAG;YACd,OAAO,OAAO,GAAG;QACnB;QAEA,oHAAQ,CAAC,UAAU,CAAC,EAAE,CAAC,gBAAgB;YACrC,QAAQ,IAAI,CAAC;YACb,OAAO,IAAI,GAAG;YACd,OAAO,OAAO,GAAG;QACnB;QAEA,OAAO,OAAO,IAAI;IACpB,EAAE,OAAO,OAAO;QACd,OAAO,OAAO,GAAG;QACjB,OAAO,IAAI,GAAG;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAE/C,sCAAsC;QACtC,IAAI,MAAM,IAAI,KAAK,gBAAgB;YACjC,QAAQ,KAAK,CACX,kDACE,+CACA,yDACA,2CACA;QAEN,OAAO,IAAI,MAAM,IAAI,KAAK,oBAAoB;YAC5C,QAAQ,KAAK,CAAC,2BAA2B,MAAM,OAAO;QACxD,OAAO,IAAI,MAAM,IAAI,KAAK,qBAAqB;YAC7C,QAAQ,KAAK,CAAC,4BAA4B,MAAM,OAAO;QACzD;QAEA,MAAM;IACR;AACF;AAMO,eAAe;IACpB,IAAI,eAAe;QACjB,OAAO,oHAAQ,CAAC,UAAU;IAC5B;IACA,6CAA6C;IAC7C,OAAO,MAAM;AACf"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/models/Post.js"],"sourcesContent":["import mongoose from \"mongoose\";\n\nconst PostSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true },\n    slug: { type: String, required: true, unique: true },\n    excerpt: { type: String },\n    content: { type: String, required: true, default: \"\" },\n    contentBlocks: { type: Array, default: [] },\n    category: { type: String, required: true },\n    featuredImage: { type: String },\n    status: {\n      type: String,\n      enum: [\"draft\", \"pending\", \"published\"],\n      default: \"draft\",\n    },\n    author: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: \"User\",\n      required: true,\n    },\n    autoShareEnabled: {\n      type: Boolean,\n      default: false,\n    },\n    publishedAt: { type: Date },\n    // SEO Fields\n    seo: {\n      metaTitle: { type: String },\n      metaDescription: { type: String },\n      metaKeywords: { type: String },\n      ogTitle: { type: String },\n      ogDescription: { type: String },\n      ogImage: { type: String },\n      twitterCard: { type: String, default: \"summary_large_image\" },\n    },\n  },\n  { timestamps: true }\n);\n\n// Generate slug from title before saving\nPostSchema.pre(\"save\", async function () {\n  try {\n    // Always generate slug if it doesn't exist or is empty\n    if (!this.slug || this.slug.trim() === \"\") {\n      if (this.title && this.title.trim() !== \"\") {\n        this.slug = this.title\n          .toLowerCase()\n          .replace(/[^a-z0-9]+/g, \"-\")\n          .replace(/(^-|-$)/g, \"\");\n      }\n    } else if (\n      this.isModified(\"title\") &&\n      this.title &&\n      this.title.trim() !== \"\"\n    ) {\n      // If title is modified, regenerate slug\n      this.slug = this.title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, \"-\")\n        .replace(/(^-|-$)/g, \"\");\n    }\n\n    // Ensure slug is not empty (fallback) - this is critical for required field\n    if (!this.slug || this.slug.trim() === \"\") {\n      const timestamp = Date.now();\n      const random = Math.random().toString(36).substring(2, 8);\n      this.slug = `post-${timestamp}-${random}`;\n    }\n\n    // Ensure slug doesn't start or end with dash\n    this.slug = this.slug.replace(/(^-|-$)/g, \"\");\n\n    if (this.status === \"published\" && !this.publishedAt) {\n      this.publishedAt = new Date();\n    }\n  } catch (error) {\n    console.error(\"Error in pre-save hook:\", error);\n    // If slug generation fails, use timestamp-based fallback\n    if (!this.slug || this.slug.trim() === \"\") {\n      const timestamp = Date.now();\n      const random = Math.random().toString(36).substring(2, 8);\n      this.slug = `post-${timestamp}-${random}`;\n    }\n  }\n});\n\nexport default mongoose.models.Post || mongoose.model(\"Post\", PostSchema);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/models/User.js"],"sourcesContent":["import mongoose from \"mongoose\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nconst UserSchema = new mongoose.Schema(\r\n  {\r\n    name: { type: String, required: true },\r\n    email: { type: String, required: true, unique: true },\r\n    password: { type: String, required: true },\r\n    role: { \r\n      type: String, \r\n      enum: ['NORMAL_USER', 'ADMIN'], \r\n      default: 'NORMAL_USER' \r\n    },\r\n    accountType: {\r\n      type: String,\r\n      enum: ['individual', 'organization'],\r\n      default: 'individual'\r\n    },\r\n    organizationName: {\r\n      type: String,\r\n      default: null\r\n    },\r\n    organizationWebsite: {\r\n      type: String,\r\n      default: null\r\n    },\r\n    organizationDescription: {\r\n      type: String,\r\n      default: null\r\n    },\r\n    autoShareEnabled: { \r\n      type: Boolean, \r\n      default: false \r\n    },\r\n    socialMediaSettings: {\r\n      facebook: { type: Boolean, default: false },\r\n      twitter: { type: Boolean, default: false },\r\n      instagram: { type: Boolean, default: false },\r\n      linkedin: { type: Boolean, default: false },\r\n      youtube: { type: Boolean, default: false },\r\n    },\r\n  },\r\n  { timestamps: true }\r\n);\r\n\r\n// Pre-save hook to hash password\r\nUserSchema.pre(\"save\", async function () {\r\n  if (!this.isModified(\"password\")) return;\r\n  this.password = await bcrypt.hash(this.password, 10);\r\n});\r\n\r\n// Pre-save hook to ensure role is always set to NORMAL_USER for new users\r\n// (unless explicitly set to ADMIN by authorized routes)\r\nUserSchema.pre(\"save\", async function () {\r\n  // Only set default role if this is a new document and role is not already set\r\n  if (this.isNew && !this.role) {\r\n    this.role = \"NORMAL_USER\";\r\n  }\r\n  // Ensure role is valid enum value\r\n  if (this.role && ![\"NORMAL_USER\", \"ADMIN\"].includes(this.role)) {\r\n    this.role = \"NORMAL_USER\";\r\n  }\r\n});\r\n\r\nexport default mongoose.models.User || mongoose.model(\"User\", UserSchema);\r\n\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,aAAa,IAAI,oHAAQ,CAAC,MAAM,CACpC;IACE,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,OAAO;QAAE,MAAM;QAAQ,UAAU;QAAM,QAAQ;IAAK;IACpD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAK;IACzC,MAAM;QACJ,MAAM;QACN,MAAM;YAAC;YAAe;SAAQ;QAC9B,SAAS;IACX;IACA,aAAa;QACX,MAAM;QACN,MAAM;YAAC;YAAc;SAAe;QACpC,SAAS;IACX;IACA,kBAAkB;QAChB,MAAM;QACN,SAAS;IACX;IACA,qBAAqB;QACnB,MAAM;QACN,SAAS;IACX;IACA,yBAAyB;QACvB,MAAM;QACN,SAAS;IACX;IACA,kBAAkB;QAChB,MAAM;QACN,SAAS;IACX;IACA,qBAAqB;QACnB,UAAU;YAAE,MAAM;YAAS,SAAS;QAAM;QAC1C,SAAS;YAAE,MAAM;YAAS,SAAS;QAAM;QACzC,WAAW;YAAE,MAAM;YAAS,SAAS;QAAM;QAC3C,UAAU;YAAE,MAAM;YAAS,SAAS;QAAM;QAC1C,SAAS;YAAE,MAAM;YAAS,SAAS;QAAM;IAC3C;AACF,GACA;IAAE,YAAY;AAAK;AAGrB,iCAAiC;AACjC,WAAW,GAAG,CAAC,QAAQ;IACrB,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa;IAClC,IAAI,CAAC,QAAQ,GAAG,MAAM,8IAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;AACnD;AAEA,0EAA0E;AAC1E,wDAAwD;AACxD,WAAW,GAAG,CAAC,QAAQ;IACrB,8EAA8E;IAC9E,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;QAC5B,IAAI,CAAC,IAAI,GAAG;IACd;IACA,kCAAkC;IAClC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;QAAC;QAAe;KAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG;QAC9D,IAAI,CAAC,IAAI,GAAG;IACd;AACF;uCAEe,oHAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,oHAAQ,CAAC,KAAK,CAAC,QAAQ"}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":["file:///F:/NNBlog/my-app/app/api/admin/post-requests/route.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { ensureConnected } from \"@/lib/moongoose\";\r\nimport Post from \"@/models/Post\";\r\nimport User from \"@/models/User\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nfunction getJWTSecret() {\r\n  return process.env.JWT_SECRET || \"your-secret-key-change-in-production\";\r\n}\r\n\r\nasync function checkAdmin(request) {\r\n  const token = request.cookies.get(\"token\")?.value;\r\n  if (!token) {\r\n    return { error: \"Not authenticated\", status: 401 };\r\n  }\r\n\r\n  try {\r\n    await ensureConnected();\r\n    const JWT_SECRET = getJWTSecret();\r\n    const decoded = jwt.verify(token, JWT_SECRET);\r\n    const user = await User.findById(decoded.userId).select(\"-password\");\r\n\r\n    if (!user || user.role !== \"ADMIN\") {\r\n      return {\r\n        error: \"Unauthorized - Admin access required\",\r\n        status: 403,\r\n      };\r\n    }\r\n\r\n    return { user };\r\n  } catch (error) {\r\n    return { error: \"Not authenticated\", status: 401 };\r\n  }\r\n}\r\n\r\n// Get all pending posts\r\nexport async function GET(request) {\r\n  const authCheck = await checkAdmin(request);\r\n  if (authCheck.error) {\r\n    return NextResponse.json(\r\n      { error: authCheck.error },\r\n      { status: authCheck.status }\r\n    );\r\n  }\r\n\r\n  try {\r\n    await ensureConnected();\r\n\r\n    // Get all posts with pending status, excluding admin posts\r\n    const posts = await Post.find({ status: \"pending\" })\r\n      .populate(\"author\", \"name email role\")\r\n      .sort({ createdAt: -1 })\r\n      .select(\"title slug excerpt category featuredImage status author createdAt contentBlocks\");\r\n\r\n    return NextResponse.json({ posts });\r\n  } catch (error) {\r\n    console.error(\"Error fetching pending posts:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to fetch pending posts\", posts: [] },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// Approve or reject a post\r\nexport async function PUT(request) {\r\n  const authCheck = await checkAdmin(request);\r\n  if (authCheck.error) {\r\n    return NextResponse.json(\r\n      { error: authCheck.error },\r\n      { status: authCheck.status }\r\n    );\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n    const { postId, action } = body;\r\n\r\n    if (!postId || !action) {\r\n      return NextResponse.json(\r\n        { error: \"Post ID and action are required\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (![\"approve\", \"reject\"].includes(action)) {\r\n      return NextResponse.json(\r\n        { error: \"Invalid action. Use 'approve' or 'reject'\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    await ensureConnected();\r\n\r\n    if (action === \"approve\") {\r\n      // Approve: Change status to published\r\n      const post = await Post.findByIdAndUpdate(\r\n        postId,\r\n        {\r\n          $set: {\r\n            status: \"published\",\r\n            publishedAt: new Date(),\r\n          },\r\n        },\r\n        { new: true }\r\n      ).populate(\"author\", \"name email\");\r\n\r\n      if (!post) {\r\n        return NextResponse.json({ error: \"Post not found\" }, { status: 404 });\r\n      }\r\n\r\n      return NextResponse.json({\r\n        post,\r\n        message: \"Post approved and published successfully\",\r\n      });\r\n    } else {\r\n      // Reject: Change status to draft (or delete - but we'll keep it as draft)\r\n      const post = await Post.findByIdAndUpdate(\r\n        postId,\r\n        {\r\n          $set: {\r\n            status: \"draft\",\r\n          },\r\n        },\r\n        { new: true }\r\n      ).populate(\"author\", \"name email\");\r\n\r\n      if (!post) {\r\n        return NextResponse.json({ error: \"Post not found\" }, { status: 404 });\r\n      }\r\n\r\n      return NextResponse.json({\r\n        post,\r\n        message: \"Post rejected successfully\",\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error updating post:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to update post\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}